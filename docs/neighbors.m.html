<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>legame.neighbors API documentation</title>
    <meta name="description" content="Provides a means for dividing up the screen into sub-sections within which MovingSprites are
cross-c..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#legame.neighbors.Neighbor">Neighbor</a></span>
        
          
  <ul>
    <li class="mono"><a href="#legame.neighbors.Neighbor.notice">notice</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#legame.neighbors.Neighborhood">Neighborhood</a></span>
        
          
  <ul>
    <li class="mono"><a href="#legame.neighbors.Neighborhood.__init__">__init__</a></li>
    <li class="mono"><a href="#legame.neighbors.Neighborhood.ignore">ignore</a></li>
    <li class="mono"><a href="#legame.neighbors.Neighborhood.notify_sprites">notify_sprites</a></li>
    <li class="mono"><a href="#legame.neighbors.Neighborhood.observe">observe</a></li>
    <li class="mono"><a href="#legame.neighbors.Neighborhood.quadrant">quadrant</a></li>
    <li class="mono"><a href="#legame.neighbors.Neighborhood.sprites_in">sprites_in</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#legame.neighbors.Quadrant">Quadrant</a></span>
        
          
  <ul>
    <li class="mono"><a href="#legame.neighbors.Quadrant.__init__">__init__</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">legame.neighbors</span> module</h1>
  <p>Provides a means for dividing up the screen into sub-sections within which MovingSprites are
cross-checked for nearness to each other. This allows MovingSprite instances to modify their
behavior on the basis of their proximity to other MovingSprites, without having to cross-check
every instance on the screen against every other instance.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors" class="source">
    <pre><code>"""
Provides a means for dividing up the screen into sub-sections within which MovingSprites are
cross-checked for nearness to each other. This allows MovingSprite instances to modify their
behavior on the basis of their proximity to other MovingSprites, without having to cross-check
every instance on the screen against every other instance.
"""

from math import floor, ceil


class Neighborhood:
	"""
	Divides an area of the screen into "Quadrant"s which are used to determine
	which sprites (or any thing really) are nearby which others.

	Quadrants are a series of squares which overlap on both the x, y axes. This
	reduces the search space when determining whether two things need to be
	notified of each other's existence.

	This can best be described visually. This is a representation of an
	Neighborhood covering a 4x3 grid. It spans 3 Quadrants on the x axis, (labeled
	0, 1, 2) and 2 quadrants on the y axis (labeled 0, 1). Inside of each cell in
	the illustration is a list of the x,y coordinates of all of the the quadrants
	which overlap that cell:

		---------------------
		|         0         |
		          ---------------------
		          |         1         |
		                    ---------------------
		                    |         2         |
		-----------------------------------------  ---
		| 0,0     | 0,0     |     2,0 |     2,0 |     |
		|         |   1,0   |   1,0   |         |     |
		|         |         |         |         |     |
		|         |         |         |         |     |
		-----------------------------------------  0  | ---
		| 0,0     | 0,0     |     2,0 |     2,0 |     |    |
		|         |   1,0   |   1,0   |         |     |    |
		|         |   1,1   |   1,1   |         |     |    |
		| 0,1     | 0,1     |     2,1 |     2,1 |     |    |
		-----------------------------------------  ---   1 |
		|         |         |         |         |          |
		|         |         |         |         |          |
		|         |   1,1   |   1,1   |         |          |
		| 0,1     | 0,1     |     2,1 |     2,1 |          |
		-----------------------------------------  --------

	Notice that each quadrant takes up four cells, and each cell shares at least
	one quadrant with all the cells surrounding it (above-left, above, above-right,
	left, right, below-left, below, below-right - 8 in total).

	Let's take a close look at the third cell from the left, third from the top.
	It is covered by two quadrants:
		1,1  2,1

	The cell immediately above it is in these quadrants:
		2,0  1,0  1,1  2,1
	... so these two cells are both in quadrant 1,1, and both in quadrant 2,1

	The cell above and to the left (second from left, second from top), is
	contained in these quadrants:
		0,0  1,0  1,1  0,1
	... so our cell (three cells from the left, three cells from the top), shares
	only quadrant 1,1

	The cell above and to the right (fourth from left, second from top), is
	contained in these quadrants:
		2,0  2,1
	... so our cell (three cells from the left, three cells from the top), shares
	only quadrant 2,1

	When an "observed" sprite is placed, it is given membership in the quadrants
	which contain the cell that it is in. Detecting interaction between sprites is
	done for every quadrant, and that reduces the amount of comparisons neccessary
	between sprites.

	To use a Neighborhood, instantiate the Neighborhood class, add the sprites you
	want notified of each other's existence using the "observe" function when they
	are instantiated, and call the "notify_sprites" function of the Neighborhood
	periodically. Typically this involves overriding the "_end_loop" function of
	the Game class and calling "notify_sprites" from there. Alternatively, you
	could call "notify_sprites" in a GameState's "loop_end" function. The only
	drawback to the second method is that you need to make sure that this call is
	made from every GameState which needs it.

	Don't forget to call the "ignore" function if/when a sprite is killed.
	Otherwise, it will remain in the list of observed sprites, and all the math
	necessary for keeping track of it will still be done. That will slow down
	your game. You might put a call to the "Neighborhood.ignore" function in the
	sprite's "kill" function.
	"""

	def __init__(self, rect, cells_x, cells_y):
		"""
		Set the area to be watched by this Neighborhood.
		(God, that sounds so Orwellian!)

		When constructing a Neighborhood, you must pass the following required
		arguments:

		rect (pygame.Rect): Identifies the area encompassing the Neighborhood.
							Only sprites in this rect will be notified of each
							others' existence. Normally,  this will be the
							Game.screen_rect, or some similar play area.
		cells_x (int)	  : The number of "cells" to divide the Neighborhood into
							on the x-axis - not "quadrants". A "quadrant" spans 3
							cells across. See the docstring for this module for a
							full explanation.
		cells_y (int)	  : The number of "cells" to divide the Neighborhood into
							on the y-axis - not "quadrants". (See "cells_x" above.)
		"""

		# Initialize either height/width based on cells_x/cells_y, or cells_x/cells_y based on height/width:
		self.rect = rect
		self.cells_x = cells_x
		self.cells_y = cells_y
		self.cell_width = self.rect.width / cells_x
		self.cell_height = self.rect.height / cells_y

		# self._quadrants is a flat, 1-dimensional list of Quadrant objects.
		# Each quadrant has an .x and .y attribute, corresponding to the first "cell" it covers.
		self._quadrants = []

		# self.__quadrant_maps is a two-dimensional which contains all the Quadrant instances, ordered by
		# their x,y coordinate which is the coordinate of the top-left cell covered by the Quadrant
		# First indice is the "x" axis, second indice is the "y" axis
		self.__quadrant_maps = [ [ None for y in range(0, self.cells_y - 1) ] for x in range(self.cells_x - 1) ]
		for x in range(self.cells_x - 1):
			for y in range(0, self.cells_y - 1):
				self._quadrants.append(Quadrant(x, y))
				self.__quadrant_maps[x][y] = self._quadrants[len(self._quadrants) - 1]

		self.count = len(self._quadrants)

		# self.cell_lookup is a 2-dimensional list, each element of which will contain a list of
		# references to the Quadrant instances which overlap that cell:
		self.__cell2quad_maps = [ [ [] for y in range(self.cells_y) ] for x in range(self.cells_x) ]

		# In a 4x3 grid, these are the class attributes:
		# cells_x:		4	- which makes for 3 quadrants across
		# cells_y:		3	- which makes for 2 quadrants down
		# quadrants:	3-across, with "x" indexes of 0, 1, 2;      2-down, with "y" indexes of 0, 1
		# __cell2quad_maps:	4-across, with "x" indexes of 0, 1, 3, 3;   3-down, with "y" indexes of 0, 1, 2
		#
		# Populate lookup tables:
		for x in range(self.cells_x - 1):			# in a 4x3 grid, iterate through 0, 1, 2
			for y in range(self.cells_y - 1):		# in a 4x3 grid, iterate through 0, 1
				for span_x in range(2):				# iterate through 0, 1
					#if x + span_x == self.cells_x: continue
					for span_y in range(2):			# iterate through 0, 1
						#if y + span_y == self.cells_y: continue
						self.__cell2quad_maps[x + span_x][y + span_y].append(self.__quadrant_maps[x][y])

		# self._observed_sprites_list are a list of all sprites to keep track of in the area:
		self._observed_sprites_list = []


	@property
	def cells(self):
		"""
		Returns a cell-to-quadrants list - really only should be used for testing.
		"""
		return self.__cell2quad_maps


	@property
	def all_quadrants(self):
		"""
		Returns the list of Quadrant objects - really only should be used for testing.
		"""
		return self._quadrants


	def sprites_in(self, x, y):
		"""
		Returns a list of sprites which occupy the quadrant specified by the given x/y coordinates.
		"""
		return self.__quadrant_maps[x][y].sprites


	def quadrant(self, x, y):
		"""
		Returns the single quadrant whose "top-left cell" occupies the "cell" x/y position given.
		"""
		return self.__quadrant_maps[x][y]


	def observe(self, sprite):
		"""
		Add a sprite to observe.
		You can add the same sprite more than once. All it will do is slow down your game.
		Don't do that.
		"""
		self._observed_sprites_list.append(sprite)


	def ignore(self, sprite):
		"""
		Remove a sprite from the list of sprites to observe.
		Hopefully, you haven't added it twice, because if so, it'll still be here.
		"""
		self._observed_sprites_list.remove(sprite)


	def notify_sprites(self):
		"""
		Re-calculate quadrant membership of all the sprites observed and notify the observed sprites
		when another observed sprite is within the same quadrant.
		"""
		for quadrant in self._quadrants:
			quadrant.sprites.clear()
		for sprite in self._observed_sprites_list:
			try:
				for quadrant in self.__cell2quad_maps[floor(sprite.x / self.cell_width)][floor(sprite.y / self.cell_height)]:
					quadrant.sprites.append(sprite)
			except IndexError:
				pass
		for quadrant in self._quadrants:
			cnt = len(quadrant.sprites)
			if cnt > 1:
				for a in range(cnt - 1):
					for b in range(a + 1, cnt):
						quadrant.sprites[a].notice(quadrant.sprites[b])
						quadrant.sprites[b].notice(quadrant.sprites[a])



class Quadrant:
	"""
	Division of an Neighborhood which covers at most 9 "cells".
	"""

	def __init__(self, x, y):
		self.x = x			# These values (and this whole class, really) are only
		self.y = y			# Used for debugging. The meat of this class is "sprites".
		self.sprites = []	# A list of sprites which are determined to be in this Quadrant.



class Neighbor:
	"""
	Demonstrates an implementation of the "notice" function, which is called when two things are within
	the same quadrant.
	"""

	def notice(self, neighbor):
		"""
		Informs this sprite that there's another sprite within a quadrant distance, allowing it
		"decide" what to do with the neighboring sprite.
		"""
		pass




</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="legame.neighbors.Neighbor" class="name">class <span class="ident">Neighbor</span></p>
      
  
    <div class="desc"><p>Demonstrates an implementation of the "notice" function, which is called when two things are within
the same quadrant.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighbor', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighbor" class="source">
    <pre><code>class Neighbor:
	"""
	Demonstrates an implementation of the "notice" function, which is called when two things are within
	the same quadrant.
	"""

	def notice(self, neighbor):
		"""
		Informs this sprite that there's another sprite within a quadrant distance, allowing it
		"decide" what to do with the neighboring sprite.
		"""
		pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#legame.neighbors.Neighbor">Neighbor</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="legame.neighbors.Neighbor.notice">
    <p>def <span class="ident">notice</span>(</p><p>self, neighbor)</p>
    </div>
    

    
  
    <div class="desc"><p>Informs this sprite that there's another sprite within a quadrant distance, allowing it
"decide" what to do with the neighboring sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighbor.notice', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighbor.notice" class="source">
    <pre><code>def notice(self, neighbor):
	"""
	Informs this sprite that there's another sprite within a quadrant distance, allowing it
	"decide" what to do with the neighboring sprite.
	"""
	pass
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="legame.neighbors.Neighborhood" class="name">class <span class="ident">Neighborhood</span></p>
      
  
    <div class="desc"><p>Divides an area of the screen into "Quadrant"s which are used to determine
which sprites (or any thing really) are nearby which others.</p>
<p>Quadrants are a series of squares which overlap on both the x, y axes. This
reduces the search space when determining whether two things need to be
notified of each other's existence.</p>
<p>This can best be described visually. This is a representation of an
Neighborhood covering a 4x3 grid. It spans 3 Quadrants on the x axis, (labeled
0, 1, 2) and 2 quadrants on the y axis (labeled 0, 1). Inside of each cell in
the illustration is a list of the x,y coordinates of all of the the quadrants
which overlap that cell:</p>
<pre><code>    ---------------------
    |         0         |
              ---------------------
              |         1         |
                        ---------------------
                        |         2         |
    -----------------------------------------  ---
    | 0,0     | 0,0     |     2,0 |     2,0 |     |
    |         |   1,0   |   1,0   |         |     |
    |         |         |         |         |     |
    |         |         |         |         |     |
    -----------------------------------------  0  | ---
    | 0,0     | 0,0     |     2,0 |     2,0 |     |    |
    |         |   1,0   |   1,0   |         |     |    |
    |         |   1,1   |   1,1   |         |     |    |
    | 0,1     | 0,1     |     2,1 |     2,1 |     |    |
    -----------------------------------------  ---   1 |
    |         |         |         |         |          |
    |         |         |         |         |          |
    |         |   1,1   |   1,1   |         |          |
    | 0,1     | 0,1     |     2,1 |     2,1 |          |
    -----------------------------------------  --------
</code></pre>
<p>Notice that each quadrant takes up four cells, and each cell shares at least
one quadrant with all the cells surrounding it (above-left, above, above-right,
left, right, below-left, below, below-right - 8 in total).</p>
<p>Let's take a close look at the third cell from the left, third from the top.
It is covered by two quadrants:
        1,1  2,1</p>
<p>The cell immediately above it is in these quadrants:
        2,0  1,0  1,1  2,1
... so these two cells are both in quadrant 1,1, and both in quadrant 2,1</p>
<p>The cell above and to the left (second from left, second from top), is
contained in these quadrants:
        0,0  1,0  1,1  0,1
... so our cell (three cells from the left, three cells from the top), shares
only quadrant 1,1</p>
<p>The cell above and to the right (fourth from left, second from top), is
contained in these quadrants:
        2,0  2,1
... so our cell (three cells from the left, three cells from the top), shares
only quadrant 2,1</p>
<p>When an "observed" sprite is placed, it is given membership in the quadrants
which contain the cell that it is in. Detecting interaction between sprites is
done for every quadrant, and that reduces the amount of comparisons neccessary
between sprites.</p>
<p>To use a Neighborhood, instantiate the Neighborhood class, add the sprites you
want notified of each other's existence using the "observe" function when they
are instantiated, and call the "notify_sprites" function of the Neighborhood
periodically. Typically this involves overriding the "_end_loop" function of
the Game class and calling "notify_sprites" from there. Alternatively, you
could call "notify_sprites" in a GameState's "loop_end" function. The only
drawback to the second method is that you need to make sure that this call is
made from every GameState which needs it.</p>
<p>Don't forget to call the "ignore" function if/when a sprite is killed.
Otherwise, it will remain in the list of observed sprites, and all the math
necessary for keeping track of it will still be done. That will slow down
your game. You might put a call to the "Neighborhood.ignore" function in the
sprite's "kill" function.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighborhood', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighborhood" class="source">
    <pre><code>class Neighborhood:
	"""
	Divides an area of the screen into "Quadrant"s which are used to determine
	which sprites (or any thing really) are nearby which others.

	Quadrants are a series of squares which overlap on both the x, y axes. This
	reduces the search space when determining whether two things need to be
	notified of each other's existence.

	This can best be described visually. This is a representation of an
	Neighborhood covering a 4x3 grid. It spans 3 Quadrants on the x axis, (labeled
	0, 1, 2) and 2 quadrants on the y axis (labeled 0, 1). Inside of each cell in
	the illustration is a list of the x,y coordinates of all of the the quadrants
	which overlap that cell:

		---------------------
		|         0         |
		          ---------------------
		          |         1         |
		                    ---------------------
		                    |         2         |
		-----------------------------------------  ---
		| 0,0     | 0,0     |     2,0 |     2,0 |     |
		|         |   1,0   |   1,0   |         |     |
		|         |         |         |         |     |
		|         |         |         |         |     |
		-----------------------------------------  0  | ---
		| 0,0     | 0,0     |     2,0 |     2,0 |     |    |
		|         |   1,0   |   1,0   |         |     |    |
		|         |   1,1   |   1,1   |         |     |    |
		| 0,1     | 0,1     |     2,1 |     2,1 |     |    |
		-----------------------------------------  ---   1 |
		|         |         |         |         |          |
		|         |         |         |         |          |
		|         |   1,1   |   1,1   |         |          |
		| 0,1     | 0,1     |     2,1 |     2,1 |          |
		-----------------------------------------  --------

	Notice that each quadrant takes up four cells, and each cell shares at least
	one quadrant with all the cells surrounding it (above-left, above, above-right,
	left, right, below-left, below, below-right - 8 in total).

	Let's take a close look at the third cell from the left, third from the top.
	It is covered by two quadrants:
		1,1  2,1

	The cell immediately above it is in these quadrants:
		2,0  1,0  1,1  2,1
	... so these two cells are both in quadrant 1,1, and both in quadrant 2,1

	The cell above and to the left (second from left, second from top), is
	contained in these quadrants:
		0,0  1,0  1,1  0,1
	... so our cell (three cells from the left, three cells from the top), shares
	only quadrant 1,1

	The cell above and to the right (fourth from left, second from top), is
	contained in these quadrants:
		2,0  2,1
	... so our cell (three cells from the left, three cells from the top), shares
	only quadrant 2,1

	When an "observed" sprite is placed, it is given membership in the quadrants
	which contain the cell that it is in. Detecting interaction between sprites is
	done for every quadrant, and that reduces the amount of comparisons neccessary
	between sprites.

	To use a Neighborhood, instantiate the Neighborhood class, add the sprites you
	want notified of each other's existence using the "observe" function when they
	are instantiated, and call the "notify_sprites" function of the Neighborhood
	periodically. Typically this involves overriding the "_end_loop" function of
	the Game class and calling "notify_sprites" from there. Alternatively, you
	could call "notify_sprites" in a GameState's "loop_end" function. The only
	drawback to the second method is that you need to make sure that this call is
	made from every GameState which needs it.

	Don't forget to call the "ignore" function if/when a sprite is killed.
	Otherwise, it will remain in the list of observed sprites, and all the math
	necessary for keeping track of it will still be done. That will slow down
	your game. You might put a call to the "Neighborhood.ignore" function in the
	sprite's "kill" function.
	"""

	def __init__(self, rect, cells_x, cells_y):
		"""
		Set the area to be watched by this Neighborhood.
		(God, that sounds so Orwellian!)

		When constructing a Neighborhood, you must pass the following required
		arguments:

		rect (pygame.Rect): Identifies the area encompassing the Neighborhood.
							Only sprites in this rect will be notified of each
							others' existence. Normally,  this will be the
							Game.screen_rect, or some similar play area.
		cells_x (int)	  : The number of "cells" to divide the Neighborhood into
							on the x-axis - not "quadrants". A "quadrant" spans 3
							cells across. See the docstring for this module for a
							full explanation.
		cells_y (int)	  : The number of "cells" to divide the Neighborhood into
							on the y-axis - not "quadrants". (See "cells_x" above.)
		"""

		# Initialize either height/width based on cells_x/cells_y, or cells_x/cells_y based on height/width:
		self.rect = rect
		self.cells_x = cells_x
		self.cells_y = cells_y
		self.cell_width = self.rect.width / cells_x
		self.cell_height = self.rect.height / cells_y

		# self._quadrants is a flat, 1-dimensional list of Quadrant objects.
		# Each quadrant has an .x and .y attribute, corresponding to the first "cell" it covers.
		self._quadrants = []

		# self.__quadrant_maps is a two-dimensional which contains all the Quadrant instances, ordered by
		# their x,y coordinate which is the coordinate of the top-left cell covered by the Quadrant
		# First indice is the "x" axis, second indice is the "y" axis
		self.__quadrant_maps = [ [ None for y in range(0, self.cells_y - 1) ] for x in range(self.cells_x - 1) ]
		for x in range(self.cells_x - 1):
			for y in range(0, self.cells_y - 1):
				self._quadrants.append(Quadrant(x, y))
				self.__quadrant_maps[x][y] = self._quadrants[len(self._quadrants) - 1]

		self.count = len(self._quadrants)

		# self.cell_lookup is a 2-dimensional list, each element of which will contain a list of
		# references to the Quadrant instances which overlap that cell:
		self.__cell2quad_maps = [ [ [] for y in range(self.cells_y) ] for x in range(self.cells_x) ]

		# In a 4x3 grid, these are the class attributes:
		# cells_x:		4	- which makes for 3 quadrants across
		# cells_y:		3	- which makes for 2 quadrants down
		# quadrants:	3-across, with "x" indexes of 0, 1, 2;      2-down, with "y" indexes of 0, 1
		# __cell2quad_maps:	4-across, with "x" indexes of 0, 1, 3, 3;   3-down, with "y" indexes of 0, 1, 2
		#
		# Populate lookup tables:
		for x in range(self.cells_x - 1):			# in a 4x3 grid, iterate through 0, 1, 2
			for y in range(self.cells_y - 1):		# in a 4x3 grid, iterate through 0, 1
				for span_x in range(2):				# iterate through 0, 1
					#if x + span_x == self.cells_x: continue
					for span_y in range(2):			# iterate through 0, 1
						#if y + span_y == self.cells_y: continue
						self.__cell2quad_maps[x + span_x][y + span_y].append(self.__quadrant_maps[x][y])

		# self._observed_sprites_list are a list of all sprites to keep track of in the area:
		self._observed_sprites_list = []


	@property
	def cells(self):
		"""
		Returns a cell-to-quadrants list - really only should be used for testing.
		"""
		return self.__cell2quad_maps


	@property
	def all_quadrants(self):
		"""
		Returns the list of Quadrant objects - really only should be used for testing.
		"""
		return self._quadrants


	def sprites_in(self, x, y):
		"""
		Returns a list of sprites which occupy the quadrant specified by the given x/y coordinates.
		"""
		return self.__quadrant_maps[x][y].sprites


	def quadrant(self, x, y):
		"""
		Returns the single quadrant whose "top-left cell" occupies the "cell" x/y position given.
		"""
		return self.__quadrant_maps[x][y]


	def observe(self, sprite):
		"""
		Add a sprite to observe.
		You can add the same sprite more than once. All it will do is slow down your game.
		Don't do that.
		"""
		self._observed_sprites_list.append(sprite)


	def ignore(self, sprite):
		"""
		Remove a sprite from the list of sprites to observe.
		Hopefully, you haven't added it twice, because if so, it'll still be here.
		"""
		self._observed_sprites_list.remove(sprite)


	def notify_sprites(self):
		"""
		Re-calculate quadrant membership of all the sprites observed and notify the observed sprites
		when another observed sprite is within the same quadrant.
		"""
		for quadrant in self._quadrants:
			quadrant.sprites.clear()
		for sprite in self._observed_sprites_list:
			try:
				for quadrant in self.__cell2quad_maps[floor(sprite.x / self.cell_width)][floor(sprite.y / self.cell_height)]:
					quadrant.sprites.append(sprite)
			except IndexError:
				pass
		for quadrant in self._quadrants:
			cnt = len(quadrant.sprites)
			if cnt > 1:
				for a in range(cnt - 1):
					for b in range(a + 1, cnt):
						quadrant.sprites[a].notice(quadrant.sprites[b])
						quadrant.sprites[b].notice(quadrant.sprites[a])
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#legame.neighbors.Neighborhood">Neighborhood</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="legame.neighbors.Neighborhood.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, rect, cells_x, cells_y)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the area to be watched by this Neighborhood.
(God, that sounds so Orwellian!)</p>
<p>When constructing a Neighborhood, you must pass the following required
arguments:</p>
<p>rect (pygame.Rect): Identifies the area encompassing the Neighborhood.
                                        Only sprites in this rect will be notified of each
                                        others' existence. Normally,  this will be the
                                        Game.screen_rect, or some similar play area.
cells_x (int)     : The number of "cells" to divide the Neighborhood into
                                        on the x-axis - not "quadrants". A "quadrant" spans 3
                                        cells across. See the docstring for this module for a
                                        full explanation.
cells_y (int)     : The number of "cells" to divide the Neighborhood into
                                        on the y-axis - not "quadrants". (See "cells_x" above.)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighborhood.__init__', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighborhood.__init__" class="source">
    <pre><code>def __init__(self, rect, cells_x, cells_y):
	"""
	Set the area to be watched by this Neighborhood.
	(God, that sounds so Orwellian!)
	When constructing a Neighborhood, you must pass the following required
	arguments:
	rect (pygame.Rect): Identifies the area encompassing the Neighborhood.
						Only sprites in this rect will be notified of each
						others' existence. Normally,  this will be the
						Game.screen_rect, or some similar play area.
	cells_x (int)	  : The number of "cells" to divide the Neighborhood into
						on the x-axis - not "quadrants". A "quadrant" spans 3
						cells across. See the docstring for this module for a
						full explanation.
	cells_y (int)	  : The number of "cells" to divide the Neighborhood into
						on the y-axis - not "quadrants". (See "cells_x" above.)
	"""
	# Initialize either height/width based on cells_x/cells_y, or cells_x/cells_y based on height/width:
	self.rect = rect
	self.cells_x = cells_x
	self.cells_y = cells_y
	self.cell_width = self.rect.width / cells_x
	self.cell_height = self.rect.height / cells_y
	# self._quadrants is a flat, 1-dimensional list of Quadrant objects.
	# Each quadrant has an .x and .y attribute, corresponding to the first "cell" it covers.
	self._quadrants = []
	# self.__quadrant_maps is a two-dimensional which contains all the Quadrant instances, ordered by
	# their x,y coordinate which is the coordinate of the top-left cell covered by the Quadrant
	# First indice is the "x" axis, second indice is the "y" axis
	self.__quadrant_maps = [ [ None for y in range(0, self.cells_y - 1) ] for x in range(self.cells_x - 1) ]
	for x in range(self.cells_x - 1):
		for y in range(0, self.cells_y - 1):
			self._quadrants.append(Quadrant(x, y))
			self.__quadrant_maps[x][y] = self._quadrants[len(self._quadrants) - 1]
	self.count = len(self._quadrants)
	# self.cell_lookup is a 2-dimensional list, each element of which will contain a list of
	# references to the Quadrant instances which overlap that cell:
	self.__cell2quad_maps = [ [ [] for y in range(self.cells_y) ] for x in range(self.cells_x) ]
	# In a 4x3 grid, these are the class attributes:
	# cells_x:		4	- which makes for 3 quadrants across
	# cells_y:		3	- which makes for 2 quadrants down
	# quadrants:	3-across, with "x" indexes of 0, 1, 2;      2-down, with "y" indexes of 0, 1
	# __cell2quad_maps:	4-across, with "x" indexes of 0, 1, 3, 3;   3-down, with "y" indexes of 0, 1, 2
	#
	# Populate lookup tables:
	for x in range(self.cells_x - 1):			# in a 4x3 grid, iterate through 0, 1, 2
		for y in range(self.cells_y - 1):		# in a 4x3 grid, iterate through 0, 1
			for span_x in range(2):				# iterate through 0, 1
				#if x + span_x == self.cells_x: continue
				for span_y in range(2):			# iterate through 0, 1
					#if y + span_y == self.cells_y: continue
					self.__cell2quad_maps[x + span_x][y + span_y].append(self.__quadrant_maps[x][y])
	# self._observed_sprites_list are a list of all sprites to keep track of in the area:
	self._observed_sprites_list = []
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="legame.neighbors.Neighborhood.ignore">
    <p>def <span class="ident">ignore</span>(</p><p>self, sprite)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove a sprite from the list of sprites to observe.
Hopefully, you haven't added it twice, because if so, it'll still be here.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighborhood.ignore', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighborhood.ignore" class="source">
    <pre><code>def ignore(self, sprite):
	"""
	Remove a sprite from the list of sprites to observe.
	Hopefully, you haven't added it twice, because if so, it'll still be here.
	"""
	self._observed_sprites_list.remove(sprite)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="legame.neighbors.Neighborhood.notify_sprites">
    <p>def <span class="ident">notify_sprites</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Re-calculate quadrant membership of all the sprites observed and notify the observed sprites
when another observed sprite is within the same quadrant.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighborhood.notify_sprites', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighborhood.notify_sprites" class="source">
    <pre><code>def notify_sprites(self):
	"""
	Re-calculate quadrant membership of all the sprites observed and notify the observed sprites
	when another observed sprite is within the same quadrant.
	"""
	for quadrant in self._quadrants:
		quadrant.sprites.clear()
	for sprite in self._observed_sprites_list:
		try:
			for quadrant in self.__cell2quad_maps[floor(sprite.x / self.cell_width)][floor(sprite.y / self.cell_height)]:
				quadrant.sprites.append(sprite)
		except IndexError:
			pass
	for quadrant in self._quadrants:
		cnt = len(quadrant.sprites)
		if cnt > 1:
			for a in range(cnt - 1):
				for b in range(a + 1, cnt):
					quadrant.sprites[a].notice(quadrant.sprites[b])
					quadrant.sprites[b].notice(quadrant.sprites[a])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="legame.neighbors.Neighborhood.observe">
    <p>def <span class="ident">observe</span>(</p><p>self, sprite)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a sprite to observe.
You can add the same sprite more than once. All it will do is slow down your game.
Don't do that.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighborhood.observe', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighborhood.observe" class="source">
    <pre><code>def observe(self, sprite):
	"""
	Add a sprite to observe.
	You can add the same sprite more than once. All it will do is slow down your game.
	Don't do that.
	"""
	self._observed_sprites_list.append(sprite)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="legame.neighbors.Neighborhood.quadrant">
    <p>def <span class="ident">quadrant</span>(</p><p>self, x, y)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the single quadrant whose "top-left cell" occupies the "cell" x/y position given.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighborhood.quadrant', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighborhood.quadrant" class="source">
    <pre><code>def quadrant(self, x, y):
	"""
	Returns the single quadrant whose "top-left cell" occupies the "cell" x/y position given.
	"""
	return self.__quadrant_maps[x][y]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="legame.neighbors.Neighborhood.sprites_in">
    <p>def <span class="ident">sprites_in</span>(</p><p>self, x, y)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a list of sprites which occupy the quadrant specified by the given x/y coordinates.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Neighborhood.sprites_in', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Neighborhood.sprites_in" class="source">
    <pre><code>def sprites_in(self, x, y):
	"""
	Returns a list of sprites which occupy the quadrant specified by the given x/y coordinates.
	"""
	return self.__quadrant_maps[x][y].sprites
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="legame.neighbors.Neighborhood.all_quadrants" class="name">var <span class="ident">all_quadrants</span></p>
            

            
  
    <div class="desc"><p>Returns the list of Quadrant objects - really only should be used for testing.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Neighborhood.cell_height" class="name">var <span class="ident">cell_height</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Neighborhood.cell_width" class="name">var <span class="ident">cell_width</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Neighborhood.cells" class="name">var <span class="ident">cells</span></p>
            

            
  
    <div class="desc"><p>Returns a cell-to-quadrants list - really only should be used for testing.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Neighborhood.cells_x" class="name">var <span class="ident">cells_x</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Neighborhood.cells_y" class="name">var <span class="ident">cells_y</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Neighborhood.count" class="name">var <span class="ident">count</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Neighborhood.rect" class="name">var <span class="ident">rect</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="legame.neighbors.Quadrant" class="name">class <span class="ident">Quadrant</span></p>
      
  
    <div class="desc"><p>Division of an Neighborhood which covers at most 9 "cells".</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Quadrant', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Quadrant" class="source">
    <pre><code>class Quadrant:
	"""
	Division of an Neighborhood which covers at most 9 "cells".
	"""

	def __init__(self, x, y):
		self.x = x			# These values (and this whole class, really) are only
		self.y = y			# Used for debugging. The meat of this class is "sprites".
		self.sprites = []	# A list of sprites which are determined to be in this Quadrant.
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#legame.neighbors.Quadrant">Quadrant</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="legame.neighbors.Quadrant.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, x, y)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-legame.neighbors.Quadrant.__init__', this);">Show source &equiv;</a></p>
  <div id="source-legame.neighbors.Quadrant.__init__" class="source">
    <pre><code>def __init__(self, x, y):
	self.x = x			# These values (and this whole class, really) are only
	self.y = y			# Used for debugging. The meat of this class is "sprites".
	self.sprites = []	# A list of sprites which are determined to be in this Quadrant.
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="legame.neighbors.Quadrant.sprites" class="name">var <span class="ident">sprites</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Quadrant.x" class="name">var <span class="ident">x</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="legame.neighbors.Quadrant.y" class="name">var <span class="ident">y</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
